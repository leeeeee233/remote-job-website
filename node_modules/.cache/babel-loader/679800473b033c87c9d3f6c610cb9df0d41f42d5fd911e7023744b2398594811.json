{"ast":null,"code":"// 缓存服务\n// 提供内存缓存和本地存储缓存功能\n\nclass CacheService {\n  constructor(options = {}) {\n    this.options = {\n      memoryTTL: 5 * 60 * 1000,\n      // 内存缓存默认5分钟\n      storageTTL: 60 * 60 * 1000,\n      // 本地存储缓存默认1小时\n      prefix: 'job_api_cache_',\n      ...options\n    };\n\n    // 内存缓存\n    this.memoryCache = new Map();\n\n    // 缓存统计\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      memoryHits: 0,\n      storageHits: 0\n    };\n  }\n\n  /**\r\n   * 生成缓存键\r\n   * @param {string} key - 原始键\r\n   * @returns {string} - 带前缀的缓存键\r\n   */\n  getCacheKey(key) {\n    return `${this.options.prefix}${key}`;\n  }\n\n  /**\r\n   * 从缓存中获取数据\r\n   * @param {string} key - 缓存键\r\n   * @returns {Promise<any>} - 缓存数据，如果不存在则返回null\r\n   */\n  async get(key) {\n    const cacheKey = this.getCacheKey(key);\n\n    // 首先检查内存缓存\n    if (this.memoryCache.has(cacheKey)) {\n      const cacheItem = this.memoryCache.get(cacheKey);\n\n      // 检查是否过期\n      if (cacheItem.expiry > Date.now()) {\n        this.stats.hits++;\n        this.stats.memoryHits++;\n        return cacheItem.value;\n      } else {\n        // 过期则删除\n        this.memoryCache.delete(cacheKey);\n      }\n    }\n\n    // 然后检查本地存储\n    try {\n      const storageItem = localStorage.getItem(cacheKey);\n      if (storageItem) {\n        const cacheItem = JSON.parse(storageItem);\n\n        // 检查是否过期\n        if (cacheItem.expiry > Date.now()) {\n          // 同时更新内存缓存\n          this.memoryCache.set(cacheKey, cacheItem);\n          this.stats.hits++;\n          this.stats.storageHits++;\n          return cacheItem.value;\n        } else {\n          // 过期则删除\n          localStorage.removeItem(cacheKey);\n        }\n      }\n    } catch (error) {\n      console.error('Error reading from localStorage:', error);\n    }\n\n    // 缓存未命中\n    this.stats.misses++;\n    return null;\n  }\n\n  /**\r\n   * 将数据存入缓存\r\n   * @param {string} key - 缓存键\r\n   * @param {any} value - 缓存数据\r\n   * @param {number} ttl - 过期时间（毫秒），如果不指定则使用默认值\r\n   * @returns {Promise<void>}\r\n   */\n  async set(key, value, ttl) {\n    const cacheKey = this.getCacheKey(key);\n    const memoryTTL = ttl || this.options.memoryTTL;\n    const storageTTL = ttl || this.options.storageTTL;\n    const now = Date.now();\n\n    // 设置内存缓存\n    const memoryCacheItem = {\n      value,\n      expiry: now + memoryTTL,\n      created: now\n    };\n    this.memoryCache.set(cacheKey, memoryCacheItem);\n\n    // 设置本地存储缓存\n    try {\n      const storageCacheItem = {\n        value,\n        expiry: now + storageTTL,\n        created: now\n      };\n      localStorage.setItem(cacheKey, JSON.stringify(storageCacheItem));\n    } catch (error) {\n      console.error('Error writing to localStorage:', error);\n    }\n  }\n\n  /**\r\n   * 使缓存项失效\r\n   * @param {string} key - 缓存键\r\n   * @returns {Promise<void>}\r\n   */\n  async invalidate(key) {\n    const cacheKey = this.getCacheKey(key);\n\n    // 删除内存缓存\n    this.memoryCache.delete(cacheKey);\n\n    // 删除本地存储缓存\n    try {\n      localStorage.removeItem(cacheKey);\n    } catch (error) {\n      console.error('Error removing item from localStorage:', error);\n    }\n  }\n\n  /**\r\n   * 清除所有缓存\r\n   * @returns {Promise<void>}\r\n   */\n  async clear() {\n    // 清除内存缓存\n    this.memoryCache.clear();\n\n    // 清除本地存储缓存\n    try {\n      const keysToRemove = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key.startsWith(this.options.prefix)) {\n          keysToRemove.push(key);\n        }\n      }\n      keysToRemove.forEach(key => localStorage.removeItem(key));\n    } catch (error) {\n      console.error('Error clearing localStorage:', error);\n    }\n\n    // 重置统计\n    this.resetStats();\n  }\n\n  /**\r\n   * 重置缓存统计\r\n   */\n  resetStats() {\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      memoryHits: 0,\n      storageHits: 0\n    };\n  }\n\n  /**\r\n   * 获取缓存统计\r\n   * @returns {Object} - 缓存统计\r\n   */\n  getStats() {\n    const total = this.stats.hits + this.stats.misses;\n    const hitRate = total > 0 ? this.stats.hits / total * 100 : 0;\n    return {\n      ...this.stats,\n      total,\n      hitRate: hitRate.toFixed(2) + '%',\n      memoryItems: this.memoryCache.size,\n      memoryUsage: this.estimateMemoryUsage()\n    };\n  }\n\n  /**\r\n   * 估算内存缓存使用量\r\n   * @returns {string} - 格式化的内存使用量\r\n   */\n  estimateMemoryUsage() {\n    let totalSize = 0;\n    this.memoryCache.forEach((value, key) => {\n      // 估算键的大小\n      totalSize += key.length * 2; // 每个字符约2字节\n\n      // 估算值的大小\n      try {\n        const jsonSize = JSON.stringify(value).length * 2;\n        totalSize += jsonSize;\n      } catch (e) {\n        // 如果无法序列化，使用粗略估计\n        totalSize += 1024; // 假设1KB\n      }\n    });\n\n    // 格式化大小\n    if (totalSize < 1024) {\n      return `${totalSize} B`;\n    } else if (totalSize < 1024 * 1024) {\n      return `${(totalSize / 1024).toFixed(2)} KB`;\n    } else {\n      return `${(totalSize / (1024 * 1024)).toFixed(2)} MB`;\n    }\n  }\n\n  /**\r\n   * 生成基于搜索参数的缓存键\r\n   * @param {string} baseKey - 基础键\r\n   * @param {Object} params - 搜索参数\r\n   * @returns {string} - 缓存键\r\n   */\n  static generateKey(baseKey, params = {}) {\n    if (!params || Object.keys(params).length === 0) {\n      return baseKey;\n    }\n\n    // 对参数进行排序，确保相同参数生成相同的键\n    const sortedParams = Object.entries(params).filter(([_, value]) => value !== undefined && value !== null && value !== '').sort(([keyA], [keyB]) => keyA.localeCompare(keyB)).map(([key, value]) => `${key}=${value}`).join('&');\n    return sortedParams ? `${baseKey}?${sortedParams}` : baseKey;\n  }\n}\nexport default CacheService;","map":{"version":3,"names":["CacheService","constructor","options","memoryTTL","storageTTL","prefix","memoryCache","Map","stats","hits","misses","memoryHits","storageHits","getCacheKey","key","get","cacheKey","has","cacheItem","expiry","Date","now","value","delete","storageItem","localStorage","getItem","JSON","parse","set","removeItem","error","console","ttl","memoryCacheItem","created","storageCacheItem","setItem","stringify","invalidate","clear","keysToRemove","i","length","startsWith","push","forEach","resetStats","getStats","total","hitRate","toFixed","memoryItems","size","memoryUsage","estimateMemoryUsage","totalSize","jsonSize","e","generateKey","baseKey","params","Object","keys","sortedParams","entries","filter","_","undefined","sort","keyA","keyB","localeCompare","map","join"],"sources":["D:/Kiro/remote-job-website/src/services/api/CacheService.js"],"sourcesContent":["// 缓存服务\r\n// 提供内存缓存和本地存储缓存功能\r\n\r\nclass CacheService {\r\n  constructor(options = {}) {\r\n    this.options = {\r\n      memoryTTL: 5 * 60 * 1000, // 内存缓存默认5分钟\r\n      storageTTL: 60 * 60 * 1000, // 本地存储缓存默认1小时\r\n      prefix: 'job_api_cache_',\r\n      ...options\r\n    };\r\n    \r\n    // 内存缓存\r\n    this.memoryCache = new Map();\r\n    \r\n    // 缓存统计\r\n    this.stats = {\r\n      hits: 0,\r\n      misses: 0,\r\n      memoryHits: 0,\r\n      storageHits: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 生成缓存键\r\n   * @param {string} key - 原始键\r\n   * @returns {string} - 带前缀的缓存键\r\n   */\r\n  getCacheKey(key) {\r\n    return `${this.options.prefix}${key}`;\r\n  }\r\n\r\n  /**\r\n   * 从缓存中获取数据\r\n   * @param {string} key - 缓存键\r\n   * @returns {Promise<any>} - 缓存数据，如果不存在则返回null\r\n   */\r\n  async get(key) {\r\n    const cacheKey = this.getCacheKey(key);\r\n    \r\n    // 首先检查内存缓存\r\n    if (this.memoryCache.has(cacheKey)) {\r\n      const cacheItem = this.memoryCache.get(cacheKey);\r\n      \r\n      // 检查是否过期\r\n      if (cacheItem.expiry > Date.now()) {\r\n        this.stats.hits++;\r\n        this.stats.memoryHits++;\r\n        return cacheItem.value;\r\n      } else {\r\n        // 过期则删除\r\n        this.memoryCache.delete(cacheKey);\r\n      }\r\n    }\r\n    \r\n    // 然后检查本地存储\r\n    try {\r\n      const storageItem = localStorage.getItem(cacheKey);\r\n      \r\n      if (storageItem) {\r\n        const cacheItem = JSON.parse(storageItem);\r\n        \r\n        // 检查是否过期\r\n        if (cacheItem.expiry > Date.now()) {\r\n          // 同时更新内存缓存\r\n          this.memoryCache.set(cacheKey, cacheItem);\r\n          \r\n          this.stats.hits++;\r\n          this.stats.storageHits++;\r\n          return cacheItem.value;\r\n        } else {\r\n          // 过期则删除\r\n          localStorage.removeItem(cacheKey);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error reading from localStorage:', error);\r\n    }\r\n    \r\n    // 缓存未命中\r\n    this.stats.misses++;\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * 将数据存入缓存\r\n   * @param {string} key - 缓存键\r\n   * @param {any} value - 缓存数据\r\n   * @param {number} ttl - 过期时间（毫秒），如果不指定则使用默认值\r\n   * @returns {Promise<void>}\r\n   */\r\n  async set(key, value, ttl) {\r\n    const cacheKey = this.getCacheKey(key);\r\n    const memoryTTL = ttl || this.options.memoryTTL;\r\n    const storageTTL = ttl || this.options.storageTTL;\r\n    \r\n    const now = Date.now();\r\n    \r\n    // 设置内存缓存\r\n    const memoryCacheItem = {\r\n      value,\r\n      expiry: now + memoryTTL,\r\n      created: now\r\n    };\r\n    \r\n    this.memoryCache.set(cacheKey, memoryCacheItem);\r\n    \r\n    // 设置本地存储缓存\r\n    try {\r\n      const storageCacheItem = {\r\n        value,\r\n        expiry: now + storageTTL,\r\n        created: now\r\n      };\r\n      \r\n      localStorage.setItem(cacheKey, JSON.stringify(storageCacheItem));\r\n    } catch (error) {\r\n      console.error('Error writing to localStorage:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 使缓存项失效\r\n   * @param {string} key - 缓存键\r\n   * @returns {Promise<void>}\r\n   */\r\n  async invalidate(key) {\r\n    const cacheKey = this.getCacheKey(key);\r\n    \r\n    // 删除内存缓存\r\n    this.memoryCache.delete(cacheKey);\r\n    \r\n    // 删除本地存储缓存\r\n    try {\r\n      localStorage.removeItem(cacheKey);\r\n    } catch (error) {\r\n      console.error('Error removing item from localStorage:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 清除所有缓存\r\n   * @returns {Promise<void>}\r\n   */\r\n  async clear() {\r\n    // 清除内存缓存\r\n    this.memoryCache.clear();\r\n    \r\n    // 清除本地存储缓存\r\n    try {\r\n      const keysToRemove = [];\r\n      \r\n      for (let i = 0; i < localStorage.length; i++) {\r\n        const key = localStorage.key(i);\r\n        if (key.startsWith(this.options.prefix)) {\r\n          keysToRemove.push(key);\r\n        }\r\n      }\r\n      \r\n      keysToRemove.forEach(key => localStorage.removeItem(key));\r\n    } catch (error) {\r\n      console.error('Error clearing localStorage:', error);\r\n    }\r\n    \r\n    // 重置统计\r\n    this.resetStats();\r\n  }\r\n\r\n  /**\r\n   * 重置缓存统计\r\n   */\r\n  resetStats() {\r\n    this.stats = {\r\n      hits: 0,\r\n      misses: 0,\r\n      memoryHits: 0,\r\n      storageHits: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 获取缓存统计\r\n   * @returns {Object} - 缓存统计\r\n   */\r\n  getStats() {\r\n    const total = this.stats.hits + this.stats.misses;\r\n    const hitRate = total > 0 ? (this.stats.hits / total) * 100 : 0;\r\n    \r\n    return {\r\n      ...this.stats,\r\n      total,\r\n      hitRate: hitRate.toFixed(2) + '%',\r\n      memoryItems: this.memoryCache.size,\r\n      memoryUsage: this.estimateMemoryUsage()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 估算内存缓存使用量\r\n   * @returns {string} - 格式化的内存使用量\r\n   */\r\n  estimateMemoryUsage() {\r\n    let totalSize = 0;\r\n    \r\n    this.memoryCache.forEach((value, key) => {\r\n      // 估算键的大小\r\n      totalSize += key.length * 2; // 每个字符约2字节\r\n      \r\n      // 估算值的大小\r\n      try {\r\n        const jsonSize = JSON.stringify(value).length * 2;\r\n        totalSize += jsonSize;\r\n      } catch (e) {\r\n        // 如果无法序列化，使用粗略估计\r\n        totalSize += 1024; // 假设1KB\r\n      }\r\n    });\r\n    \r\n    // 格式化大小\r\n    if (totalSize < 1024) {\r\n      return `${totalSize} B`;\r\n    } else if (totalSize < 1024 * 1024) {\r\n      return `${(totalSize / 1024).toFixed(2)} KB`;\r\n    } else {\r\n      return `${(totalSize / (1024 * 1024)).toFixed(2)} MB`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 生成基于搜索参数的缓存键\r\n   * @param {string} baseKey - 基础键\r\n   * @param {Object} params - 搜索参数\r\n   * @returns {string} - 缓存键\r\n   */\r\n  static generateKey(baseKey, params = {}) {\r\n    if (!params || Object.keys(params).length === 0) {\r\n      return baseKey;\r\n    }\r\n    \r\n    // 对参数进行排序，确保相同参数生成相同的键\r\n    const sortedParams = Object.entries(params)\r\n      .filter(([_, value]) => value !== undefined && value !== null && value !== '')\r\n      .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))\r\n      .map(([key, value]) => `${key}=${value}`)\r\n      .join('&');\r\n    \r\n    return sortedParams ? `${baseKey}?${sortedParams}` : baseKey;\r\n  }\r\n}\r\n\r\nexport default CacheService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}