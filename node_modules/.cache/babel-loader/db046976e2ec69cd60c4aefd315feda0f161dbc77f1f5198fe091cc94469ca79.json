{"ast":null,"code":"// API适配器基类\n// 提供通用的API请求方法和错误处理\n\nclass ApiAdapter {\n  constructor(baseUrl, options = {}) {\n    this.baseUrl = baseUrl;\n    this.options = {\n      maxRetries: 3,\n      retryDelay: 1000,\n      timeout: 10000,\n      ...options\n    };\n  }\n\n  /**\r\n   * 发送HTTP请求，支持重试和超时\r\n   * @param {string} endpoint - API端点\r\n   * @param {Object} options - 请求选项\r\n   * @param {number} retryCount - 当前重试次数\r\n   * @returns {Promise<Object>} - 响应数据\r\n   */\n  async request(endpoint, options = {}, retryCount = 0) {\n    const url = endpoint.startsWith('http') ? endpoint : `${this.baseUrl}${endpoint}`;\n    const fetchOptions = {\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers\n      },\n      signal: AbortSignal.timeout(this.options.timeout)\n    };\n    try {\n      const response = await fetch(url, fetchOptions);\n      if (!response.ok) {\n        throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);\n      }\n      return await response.json();\n    } catch (error) {\n      // 处理超时和网络错误\n      if (error.name === 'AbortError') {\n        console.error(`Request timeout for ${url}`);\n      } else {\n        console.error(`Request error for ${url}:`, error);\n      }\n\n      // 实现重试逻辑\n      if (retryCount < this.options.maxRetries) {\n        const delay = this.options.retryDelay * Math.pow(2, retryCount);\n        console.log(`Retrying request to ${url} in ${delay}ms (${retryCount + 1}/${this.options.maxRetries})`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.request(endpoint, options, retryCount + 1);\n      }\n      throw error;\n    }\n  }\n\n  /**\r\n   * 处理API错误\r\n   * @param {Error} error - 错误对象\r\n   * @param {string} source - 错误来源\r\n   * @returns {Object} - 标准化的错误对象\r\n   */\n  handleError(error, source) {\n    const errorInfo = {\n      message: error.message || 'Unknown error occurred',\n      source: source,\n      timestamp: new Date().toISOString(),\n      isRetryable: this.isRetryableError(error)\n    };\n    console.error(`API Error [${source}]:`, errorInfo);\n    return errorInfo;\n  }\n\n  /**\r\n   * 判断错误是否可重试\r\n   * @param {Error} error - 错误对象\r\n   * @returns {boolean} - 是否可重试\r\n   */\n  isRetryableError(error) {\n    // 网络错误、超时和服务器错误通常是可重试的\n    if (error.name === 'AbortError') return true;\n    if (error.message && error.message.includes('network')) return true;\n\n    // 检查HTTP状态码\n    if (error.status) {\n      // 5xx错误通常是服务器问题，可以重试\n      return error.status >= 500 && error.status < 600;\n    }\n    return false;\n  }\n\n  /**\r\n   * 将API特定的工作数据转换为统一格式\r\n   * 子类需要实现此方法\r\n   * @param {Object} apiJob - API返回的工作数据\r\n   * @returns {Object} - 统一格式的工作数据\r\n   */\n  transformJob(apiJob) {\n    throw new Error('transformJob method must be implemented by subclass');\n  }\n\n  /**\r\n   * 将API特定的工作详情转换为统一格式\r\n   * 子类需要实现此方法\r\n   * @param {Object} apiJobDetail - API返回的工作详情\r\n   * @returns {Object} - 统一格式的工作详情\r\n   */\n  transformJobDetail(apiJobDetail) {\n    throw new Error('transformJobDetail method must be implemented by subclass');\n  }\n}\nexport default ApiAdapter;","map":{"version":3,"names":["ApiAdapter","constructor","baseUrl","options","maxRetries","retryDelay","timeout","request","endpoint","retryCount","url","startsWith","fetchOptions","headers","signal","AbortSignal","response","fetch","ok","Error","status","statusText","json","error","name","console","delay","Math","pow","log","Promise","resolve","setTimeout","handleError","source","errorInfo","message","timestamp","Date","toISOString","isRetryable","isRetryableError","includes","transformJob","apiJob","transformJobDetail","apiJobDetail"],"sources":["D:/Kiro/remote-job-website/src/services/api/ApiAdapter.js"],"sourcesContent":["// API适配器基类\r\n// 提供通用的API请求方法和错误处理\r\n\r\nclass ApiAdapter {\r\n  constructor(baseUrl, options = {}) {\r\n    this.baseUrl = baseUrl;\r\n    this.options = {\r\n      maxRetries: 3,\r\n      retryDelay: 1000,\r\n      timeout: 10000,\r\n      ...options\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 发送HTTP请求，支持重试和超时\r\n   * @param {string} endpoint - API端点\r\n   * @param {Object} options - 请求选项\r\n   * @param {number} retryCount - 当前重试次数\r\n   * @returns {Promise<Object>} - 响应数据\r\n   */\r\n  async request(endpoint, options = {}, retryCount = 0) {\r\n    const url = endpoint.startsWith('http') ? endpoint : `${this.baseUrl}${endpoint}`;\r\n    \r\n    const fetchOptions = {\r\n      ...options,\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        ...options.headers\r\n      },\r\n      signal: AbortSignal.timeout(this.options.timeout)\r\n    };\r\n\r\n    try {\r\n      const response = await fetch(url, fetchOptions);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);\r\n      }\r\n      \r\n      return await response.json();\r\n    } catch (error) {\r\n      // 处理超时和网络错误\r\n      if (error.name === 'AbortError') {\r\n        console.error(`Request timeout for ${url}`);\r\n      } else {\r\n        console.error(`Request error for ${url}:`, error);\r\n      }\r\n      \r\n      // 实现重试逻辑\r\n      if (retryCount < this.options.maxRetries) {\r\n        const delay = this.options.retryDelay * Math.pow(2, retryCount);\r\n        console.log(`Retrying request to ${url} in ${delay}ms (${retryCount + 1}/${this.options.maxRetries})`);\r\n        \r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n        return this.request(endpoint, options, retryCount + 1);\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 处理API错误\r\n   * @param {Error} error - 错误对象\r\n   * @param {string} source - 错误来源\r\n   * @returns {Object} - 标准化的错误对象\r\n   */\r\n  handleError(error, source) {\r\n    const errorInfo = {\r\n      message: error.message || 'Unknown error occurred',\r\n      source: source,\r\n      timestamp: new Date().toISOString(),\r\n      isRetryable: this.isRetryableError(error)\r\n    };\r\n    \r\n    console.error(`API Error [${source}]:`, errorInfo);\r\n    \r\n    return errorInfo;\r\n  }\r\n\r\n  /**\r\n   * 判断错误是否可重试\r\n   * @param {Error} error - 错误对象\r\n   * @returns {boolean} - 是否可重试\r\n   */\r\n  isRetryableError(error) {\r\n    // 网络错误、超时和服务器错误通常是可重试的\r\n    if (error.name === 'AbortError') return true;\r\n    if (error.message && error.message.includes('network')) return true;\r\n    \r\n    // 检查HTTP状态码\r\n    if (error.status) {\r\n      // 5xx错误通常是服务器问题，可以重试\r\n      return error.status >= 500 && error.status < 600;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * 将API特定的工作数据转换为统一格式\r\n   * 子类需要实现此方法\r\n   * @param {Object} apiJob - API返回的工作数据\r\n   * @returns {Object} - 统一格式的工作数据\r\n   */\r\n  transformJob(apiJob) {\r\n    throw new Error('transformJob method must be implemented by subclass');\r\n  }\r\n\r\n  /**\r\n   * 将API特定的工作详情转换为统一格式\r\n   * 子类需要实现此方法\r\n   * @param {Object} apiJobDetail - API返回的工作详情\r\n   * @returns {Object} - 统一格式的工作详情\r\n   */\r\n  transformJobDetail(apiJobDetail) {\r\n    throw new Error('transformJobDetail method must be implemented by subclass');\r\n  }\r\n}\r\n\r\nexport default ApiAdapter;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}